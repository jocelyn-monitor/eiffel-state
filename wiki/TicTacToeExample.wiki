#summary Description and design of Tic-Tac-Toe game
#labels Unfinished

= Introduction =

Here you can find description of Tic-Tac-Toe game and its implementation with eiffel-state library.


= Brief Game Rules =

It's a step-by-step game for two players. It is played on 3x3 field. The aim of the game is to put three O or three X in a row. A person who plays with X turns first.


= Model description =

Each cell of the field is a button with complex behavior (three states empty, X and O). The game process itself is also an object with complex behavior (states are: before, X-turn, O-turn, X-won, O-won and draw).

=== First automata-based implementation: questions and problems ===
  # In traditional approach conditions can be checked _after_ performing some action. In our approach conditions ("predicates", "input variables") are checked first, and then actions are executed. Combined with the fact that there are no epsilon-transitions in our model and predicates should be pure, this leads to strange predicates such as "will there be a winning combination after cross is put in cell (i, j)?" *Possible solutions*: 1) leave everything as is and hope for the best 2) allow epsilon-transitions (hate'em!) or 3) simulate them with calls to secret procedures (e.g., make_turn always triggers put_something action _and_ check_game_over action, which is itself state-dependent; check_game_over then uses normal predicates to calculate the new state).
  # Clients often need to know the control state of the automated object (examples: functions is_empty, is_cross, is_circle in FIELD_CELL; is_over, cross_won, circle_won in GAME). I decided for hiding the state from clients anyway and introducing functions for these purposes, but it may seem like a big overhead (especially in the case of FIELD_CELL above). The question is whether we want to make control state public instead? My answer will be no, because in the end control states won't be just regular attributes, there will be a special notation for them; so they cannot be used as regular attributes, but instead we should include the possibility of control state exchange into diagrams if we want to make them public. Another possibility is to automate somehow in our future tool the generation of such functions.
  # Overall about state-dependent functions. As we see from the example, state dependent functions proved useful. However, I think, we should impose the restriction, that such functions cannot be used in transition conditions. One more thing: though these functions are state-dependent, they never change the control state (being side-effect free, like all Eiffel functions). So, in my opinion, they should not be depicted in state-transition diagram, as they just pollute diagrams with many redundant loops. We should find another notation for them.
  # Precise STD notation should be discussed. Writing full pieces of code on transitions might be inconvenient, so we probably need abbreviations in Shalyto style or something like that. Note that we don't want to make the programmer introduce a separate feature for each action or predicate. E.g. in start_new_game of WINNER_FIRST_MANAGER the actions look like "create current_game.make_first_cross" and the predicates like "current_game /= Void and then current_game.cross_won". We would probably want to allow arbitrary boolean expression as a predicate and arbitrary compound as an action. Then we would need some "abbreviation table", where the programmer can introduce abbreviations and code pieces that correspond to them. I think it's psychologically easier for a programmer to introduce a new abbreviation, than to introduce a new feature for each predicate and action.