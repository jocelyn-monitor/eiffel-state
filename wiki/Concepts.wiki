#summary Main concepts of Automata-based programming
#labels Phase-Design

= Introduction =

*Object-oriented automata-based programming* is an approach to O-O software construction, in which entities with _complex_ (_state-dependent_) behavior are represented with _automated classes_.

<wiki:comment>
Main idea of Automata-based programming approach is following: there are controlled objects with states. State of object can be changed on some event fired in the system. This event can be fired as a reaction on user input, as well as a subsequent event fired while previous event is processed.
</wiki:comment>

= Complex behavior =

Entities with _simple_ behavior always have the same _reaction_ for a certain _input_. In O-O world a class is a model of an entity with simple behavior: inputs correspond to feature names, reactions correspond to feature bodies.

In contrast, an entity with complex behavior can react differently to the same input, depending on the history. To capture this dependency, the notion of _control state_ is introduced. In presence of this notion the reaction of an entity with complex behavior depends only on the input and on the current control state. Reaction as function of input and state together with transitions between states is best expressed in a form of a _finite state transducer_ (finite automaton with output).

Entities with complex behavior are common in control and reactive systems, but there are also many examples from other kinds of software: network protocols, GUI elements, NPC in computer games and other AI-like problems, etc.

The idea behind object-oriented automata-based programming is to introduce a model for an entity with complex behavior, which will be just like a regular class from the client's point of view, but inside it will contain a finite state transducer to dispatch the calls of the same features to different "feature bodies", depending on the current control state.

= Control states vs. computational states =

Every class has a set of _computational states_, which is the set of all combinations of its attributes values. This set, though essentially finite, is in most cases immensely large. Computational states typically differ from each other only quantitavely; we can say that the result of a feature call depends on the computational state, but not the action (the algorithm) that is being executed.

In automata-based programming for each entity with complex behavior in addition to the set of computational states, the set of control states is defined. As opposed to computational states, control states are typically few, and thus defined by enumeration. Each of them has a certain meaning and qualitatively differs from all the others. Control state defines an action that is performed as a reaction to a certain input, not only the result of this actions.

The distinction between control and computational states is rather informal, it is "in the eyes of the programmer". The choice of appropriate set of control states is one of the main design decisions when implementing an automated class; it is made individually for each entity with complex behavior.

Mathematically, control states can be either predicates on computational states or be orthogonal (add some new information). As an example of the first possibility, consider a bounded stack. It behaves differently, depending on whether it is 1) empty 2) full 3) neither empty, nor full - so these could be its three control states. These states can be expressed as predicates on attributes "count" and "capacity", which are component of stack's computational state.

As an example of the second possibility, consider alarmed clock, which has three control states: "Alarm off", "Alarm setting" and "Alarm on". Computational states of the clock is defined by current time, alarm time and whether the bell is ringing. From this one cannot determine, whether the alarm is on, off, or is being set. 