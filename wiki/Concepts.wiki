#summary Main concepts of Object-oriented Automata-based programming
#labels Phase-Design

= Introduction =

*Object-oriented Automata-based programming* is an approach to O-O software construction, in which entities with _complex_ (_state-dependent_) behavior are represented with _automated classes_.

<wiki:comment>
Main idea of Automata-based programming approach is following: there are controlled objects with states. State of object can be changed on some event fired in the system. This event can be fired as a reaction on user input, as well as a subsequent event fired while previous event is processed.
</wiki:comment>

= Complex behavior =

Entities with _simple_ behavior always have the same _reaction_ for a certain _input_. In O-O world a class is a model of an entity with simple behavior: inputs correspond to feature names, reactions correspond to feature bodies.

In contrast, an entity with complex behavior can react differently to the same input, depending on the history. To capture this dependency, the notion of _control state_ is introduced. In presence of this notion the reaction of an entity with complex behavior depends only on the input and on the current control state. Reaction as function of input and state together with transitions between states is best expressed in a form of a _finite state transducer_ (finite automaton with output).

Entities with complex behavior are common in control and reactive systems, but there are also many examples from other kinds of software: network protocols, GUI elements, NPC in computer games and other AI-like problems, etc.

The idea behind Object-oriented Automata-based programming is to introduce a model for an entity with complex behavior, which will be just like a regular class from the client's point of view, but inside it will contain a finite state transducer to dispatch the calls of the same features to different "feature bodies", depending on the current control state.

= Control states vs. computational states =

Every class has a set of _computational states_, which is the set of all combinations of its attributes values. This set, though essentially finite, is in most cases immensely large. Computational states typically differ from each other only quantitavely; we can say that the result of a feature call depends on the computational state, but not the action (the algorithm) that is being executed.

In Automata-based programming for each entity with complex behavior in addition to the set of computational states, the set of control states is defined. As opposed to computational states, control states are typically few, and thus defined by enumeration. Each of them has a certain meaning and qualitatively differs from all the others. Control state defines an action that is performed as a reaction to a certain input, not only the result of this actions.

Abstract machines that are used in the theory of formal languages (Push-down automaton, Turing machine) give good examples of distinguishing between control and computational states: control states in this case are the states of their finite-state controller and the computational states are the states of the stack or the tape. 

The distinction between control and computational states is rather informal, it is "in the eyes of the programmer". The choice of appropriate set of control states is one of the main design decisions when implementing an automated class; it is made individually for each entity with complex behavior.

Mathematically, control states can be either predicates on computational states or be orthogonal (add some new information). As an example of the first possibility, consider a bounded stack. It behaves differently, depending on whether it is 1) empty 2) full 3) neither empty, nor full - so these could be its three control states. These states can be expressed as predicates on attributes "count" and "capacity", which are component of stack's computational state.

As an example of the second possibility, consider alarmed clock, which has three control states: "Alarm off", "Alarm setting" and "Alarm on". Computational states of the clock is defined by current time, alarm time and whether the bell is ringing. From this one cannot determine, whether the alarm is on, off, or is being set.

= Automated control object =

In Object-oriented Automata-based programming the description of complex behavior is decomposed into _logic_ and _semantics_. Logic part includes control states, reaction as a function of input and control states, transitions between control states and is described by a finite-state transducer. 

Semantics includes the set of computational states and specification of actions that an entity performs. Our approach also allows reactions and transitions depend on the values of predicates on the computational state. Thus, semantic part also includes specification of these predicates. The semantic part in O-O setting is represented by a class. The set of computational states is described by means of its attributes, actions correspond to its commands and predicates are expressed as boolean expressions involving its queries.

The logic part is called the _controller_ and the semantic part - the _controlled object_; the whole model or an entity with complex behavior that consists of a controller and a controlled object is called an _automated control object_ (terms come from control theory). The implementation of an automated control object in an O-O system is called _automated class_. Thus an automated class for an automated control object is the same thing as a class for an abstract data type.

The choice of the level of abstraction for the control object is closely connected with the choice of control states. Control object that is too abstract leads to to less control states, but complicates the control object itself, bringing to nothing the advantages of automata_based programming. Control object that is too concrete leads to more control states, making the controller too complex. 

= Design process =

= Unsolved problems = 