#summary Main concepts of Automata-based programming
#labels Phase-Design

= Introduction =

*Object-oriented automata-based programming* is an approach to O-O software construction, in which entities with _complex_ (_state-dependent_) behavior are represented with _automated classes_.

<wiki:comment>
Main idea of Automata-based programming approach is following: there are controlled objects with states. State of object can be changed on some event fired in the system. This event can be fired as a reaction on user input, as well as a subsequent event fired while previous event is processed.
</wiki:comment>

= Complex behavior =

Entities with _simple_ behavior always have the same _reaction_ for a certain _input_. In O-O world a class is a model of an entity with simple behavior: inputs correspond to feature names, reactions correspond to feature bodies.

In contrast, an entity with complex behavior can react differently to the same input, depending on the history. To capture this dependency, the notion of _control state_ is introduced. In presence of this notion the reaction of an entity with complex behavior depends only on the input and on the current control state. Reaction as function of input and state together with transitions between states is best expressed in a form of a _finite state transducer_ (finite automaton with output).

Entities with complex behavior are common in control and reactive systems, but there are also many examples from other kinds of software: network protocols, GUI elements, NPC in computer games and other AI-like problems, etc.

The idea behind object-oriented automata-based programming is to introduce a model for an entity with complex behavior, which will be just like a regular class from the client's point of view, but inside it will contain a finite state transducer to dispatch the calls of the same features to different "feature bodies", depending on the current control state.       